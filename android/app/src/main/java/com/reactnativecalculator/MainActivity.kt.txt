package com.reactnativecalculator

import android.content.res.Configuration
import android.graphics.Rect
import android.os.Bundle
import android.os.Build
import android.util.Log
import android.view.View
import android.view.ViewTreeObserver
import android.view.WindowInsets

import androidx.annotation.RequiresApi
import androidx.core.util.Consumer
import androidx.core.view.WindowCompat
import androidx.lifecycle.lifecycleScope
import androidx.window.java.layout.WindowInfoTrackerCallbackAdapter
import androidx.window.layout.WindowInfoTracker
import androidx.window.layout.WindowMetricsCalculator
import androidx.window.layout.WindowLayoutInfo
import androidx.window.layout.FoldingFeature

import com.facebook.react.bridge.Arguments
import com.facebook.react.bridge.LifecycleEventListener
import com.facebook.react.bridge.ReactContext
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabled
import com.facebook.react.defaults.DefaultReactActivityDelegate
import com.facebook.react.modules.core.DeviceEventManagerModule
import com.facebook.react.ReactActivity
import com.facebook.react.ReactActivityDelegate
import com.facebook.react.ReactInstanceManager.ReactInstanceEventListener

import com.reactnativecalculator.R

import com.zoontek.rnbootsplash.RNBootSplash

import expo.modules.ReactActivityDelegateWrapper

import java.util.concurrent.Executors

import kotlin.math.min
import kotlin.properties.Delegates

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.launch
import kotlinx.coroutines.Job

import androidx.lifecycle.Lifecycle
import androidx.lifecycle.repeatOnLifecycle

// OLD, THIS WORK

@Suppress("DEPRECATION")
class MainActivity : ReactActivity() {
  
  var canUpdate: Boolean = true // 1st FLAG (MANUAL or AUTO UPDATE)
  var sendUpdate: Boolean = false
  var dotsPerInch: Double by Delegates.notNull<Double>()
  var currentMaxHorizontalInset: Int by Delegates.notNull<Int>()
  var currentMaxVerticalInset: Int by Delegates.notNull<Int>()
  lateinit var rootView: View
  //private val lock = Any()
  lateinit var currentOrientation: String // UI var
  lateinit var currentState: String // UI var
  lateinit var currentInsets: Rect // UI var
  var currentWindow: MutableMap<String, Int> = mutableMapOf() // UI var
  var currentHingeBounds: MutableMap<String, Int> = mutableMapOf() // UI var



  override fun onCreate(savedInstanceState: Bundle?) {
    RNBootSplash.init(this, R.style.Start); // Initialize SplashScreen
    super.onCreate(null); // super.onCreate(savedInstanceState) // super.onCreate(null) with react-native-screens
    WindowCompat.setDecorFitsSystemWindows(window, false)
    val mainActivity = this@MainActivity
    dotsPerInch = mainActivity.resources.displayMetrics.density.toDouble() // Float --> Double
    rootView = findViewById<View>(android.R.id.content).rootView

    lifecycleScope.launch(Dispatchers.Main) {
      lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {
          WindowInfoTracker.getOrCreate(mainActivity)
              .windowLayoutInfo(mainActivity)
              .collect { newLayoutInfo ->
                //synchronized(AppLock.lock) {
                    Log.d("LOG", "AppLock.canUpdate auto " + canUpdate)
                    //if (canUpdate) updateUI(newLayoutInfo)
                    if (canUpdate) {canUpdate = false;updateUI(newLayoutInfo)} // BLOCK 1st FLAG ASAP
                    
                //}
              }
      }
   }
  }

  // override fun onResume() {
  //   super.onResume()
  //   reactInstanceManager.addReactInstanceEventListener(this)
  // }

  // override fun onPause() {
  //   super.onPause()
  //   reactInstanceManager.removeReactInstanceEventListener(this)
  // }

  fun updateUI(incomingWindowLayoutInfo: WindowLayoutInfo?) { //manual: Boolean
    Log.d("LOG", "incomingWindowLayoutInfo: " + incomingWindowLayoutInfo)
    //canUpdate = false // FLAG FOR updateUI()

    val mainActivity = this@MainActivity

    // MULTI-WINDOW // 24
    val multiWindow = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) mainActivity.isInMultiWindowMode else false

    // BEGIN ORIENTATION //
    val newOrientation = mainActivity.resources.configuration.orientation
    if (newOrientation == Configuration.ORIENTATION_PORTRAIT) { currentOrientation = "portrait" }
    else { currentOrientation = "landscape" }
    // END ORIENTATION //

    //lateinit var job: Job
    var job: Job? = null

    fun collectAndCancel(windowLayoutInfo: WindowLayoutInfo, doJob: Boolean) {
      Log.d("LOG", "DATA: " + windowLayoutInfo + ", DO JOB VALUE: " + doJob)
      if (doJob) job?.cancel(); // CANCEL CURRENT, IF ANY, JOB

      val mainMap = Arguments.createMap()

      // BEGIN WINDOW //
      val windowBounds = WindowMetricsCalculator.getOrCreate().computeCurrentWindowMetrics(mainActivity).bounds
      val newWindow = mutableMapOf("width" to windowBounds.width(), "height" to windowBounds.height())
      if (currentWindow.isEmpty() || !currentWindow.equals(newWindow)) { currentWindow = newWindow; sendUpdate = true }
      // END WINDOW //

      // BEGIN INSETS //
      @RequiresApi(Build.VERSION_CODES.R)
      fun getInsetsCompatR(rootView: View): Unit {
        val newInsets =
          rootView.rootWindowInsets?.getInsets(
            WindowInsets.Type.statusBars() or
            WindowInsets.Type.displayCutout() or
            WindowInsets.Type.navigationBars() or
            WindowInsets.Type.captionBar()
          )

        if (newInsets !== null) {
          currentInsets = Rect(newInsets.left, newInsets.top, newInsets.right, newInsets.bottom)
          sendUpdate = true
        }
      }

      @RequiresApi(Build.VERSION_CODES.M)
      fun getInsetsCompatM(rootView: View): Unit {
        val preInsets = rootView.rootWindowInsets
        if (preInsets !== null) {
          currentInsets = Rect(preInsets.systemWindowInsetLeft, preInsets.systemWindowInsetTop, preInsets.systemWindowInsetRight, min(preInsets.systemWindowInsetBottom, preInsets.stableInsetBottom))
          sendUpdate = true
        }
      }

      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) getInsetsCompatR(rootView) // 11 to newest..
      else getInsetsCompatM(rootView) // 6 to 10
      // 5 or older NOT SUPPORTED

      // END INSETS //

      // BEGIN VERTICAL & HORIZONTAL INSET //
      if (currentInsets.left > currentInsets.right) currentMaxHorizontalInset = currentInsets.left
      else currentMaxHorizontalInset = currentInsets.right
      if (currentInsets.top > currentInsets.bottom) currentMaxVerticalInset = currentInsets.top
      else currentMaxVerticalInset = currentInsets.bottom
      // END VERTICAL & HORIZONTAL INSET //

      val foldingFeature = windowLayoutInfo.displayFeatures.filterIsInstance<FoldingFeature>().firstOrNull()

      var newHingeBounds: MutableMap<String, Int> = mutableMapOf()

      lateinit var newState: String;

      if (foldingFeature != null) {
        newHingeBounds = mutableMapOf(
          "left" to foldingFeature.bounds.left,
          "top" to foldingFeature.bounds.top,
          "right" to foldingFeature.bounds.right,
          "bottom" to foldingFeature.bounds.bottom
        )

        newState =
          if ((foldingFeature.state == FoldingFeature.State.FLAT && foldingFeature.occlusionType == FoldingFeature.OcclusionType.NONE) || multiWindow) "flat"
          else if (foldingFeature.orientation == FoldingFeature.Orientation.HORIZONTAL) "tabletop"
          else "book"
      } else {
        newState = currentOrientation
        newHingeBounds = mutableMapOf("left" to 0, "top" to 0, "right" to 0, "bottom" to 0)
      }

      if (!::currentState.isInitialized || !currentState.equals(newState)) { currentState = newState; sendUpdate = true }

      if (currentHingeBounds.isEmpty() || !currentHingeBounds.equals(newHingeBounds)) { currentHingeBounds = newHingeBounds; sendUpdate = true }

      sendUpdate = true

      Log.d("LOG", "PRE SEND-UPDATE VAL: " + sendUpdate)

      if (sendUpdate) {
        Log.d("LOG", "SEND-UPDATE CALLED")
        mainMap.putMap("hingeBounds", Arguments.createMap().apply {
          putDouble("left", currentHingeBounds["left"]!! / dotsPerInch)
          putDouble("top", currentHingeBounds["top"]!! / dotsPerInch)
          putDouble("right", currentHingeBounds["right"]!! / dotsPerInch)
          putDouble("bottom", currentHingeBounds["bottom"]!! / dotsPerInch)
        });
        mainMap.putString("state", currentState); // flat, tabletop..
        mainMap.putMap("window", Arguments.createMap().apply {
          putDouble("width", currentWindow["width"]!! / dotsPerInch)
          putDouble("height", currentWindow["height"]!! / dotsPerInch)
        });
        mainMap.putMap("insets", Arguments.createMap().apply {
          putDouble("left", currentInsets.left / dotsPerInch)
          putDouble("top", currentInsets.top / dotsPerInch)
          putDouble("right", currentInsets.right / dotsPerInch)
          putDouble("bottom", currentInsets.bottom / dotsPerInch)
        });
        mainMap.putDouble("maxHorizontalInset", currentMaxHorizontalInset / dotsPerInch)
        mainMap.putDouble("maxVerticalInset", currentMaxVerticalInset / dotsPerInch)
        mainMap.putDouble("vmin",
          if (currentWindow["width"]!! > currentWindow["height"]!!) (currentWindow["height"]!! / dotsPerInch) / 100
          else (currentWindow["width"]!! / dotsPerInch) / 100
        );
        mainMap.putBoolean("tallBar", if (currentInsets.left / dotsPerInch > 47 || currentInsets.right / dotsPerInch > 47 || currentInsets.bottom / dotsPerInch > 47) true else false);

        if (reactInstanceManager.currentReactContext == null) {
          reactInstanceManager.addReactInstanceEventListener(object: ReactInstanceEventListener {
            override fun onReactContextInitialized(context: ReactContext) {
              context
                .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
                ?.emit("LayoutInfo", mainMap)
            }
          })
        } else {
          reactInstanceManager.currentReactContext
            ?.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
            ?.emit("LayoutInfo", mainMap)
        }
        sendUpdate = false // RESET UPDATE FLAG
      }
      canUpdate = true // FLAG FOR updateUI()
    } // END OF updateUI()

    if (incomingWindowLayoutInfo != null) collectAndCancel(incomingWindowLayoutInfo, false) // AUTO FOLDING FEATURE INFO
    else {
    Log.d("LOG", "LAUNCHED MANUAL JOB")
      job?.cancel(); // CANCEL PREVIOUS, IF ANY, JOB
      job = lifecycleScope.launch { // MANUAL FOLDING FEATURE INFO
        WindowInfoTracker.getOrCreate(mainActivity)
          .windowLayoutInfo(mainActivity)
          .collect { collectAndCancel(it, true) }
      };
    }
  }

  override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    
    Log.d("LOG", "CONFIGURATION HAS CHANGED")
    //updateUI(null) // manual
    //synchronized(AppLock.lock) {
      //if (canUpdate) {canUpdate = false;updateUI(null)}
      Log.d("LOG", "AppLock.canUpdate oCC " + canUpdate)
      if (canUpdate) {canUpdate = false;updateUI(null)} // BLOCK 1st FLAG ASAP
    //}
 
}

  override fun getMainComponentName(): String = "reactNativeCalculator"

  override fun createReactActivityDelegate(): ReactActivityDelegate =
    ReactActivityDelegateWrapper(this, BuildConfig.IS_NEW_ARCHITECTURE_ENABLED, DefaultReactActivityDelegate(this, mainComponentName, fabricEnabled))
}