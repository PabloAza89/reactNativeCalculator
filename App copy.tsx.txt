//import { NewAppScreen } from '@react-native/new-app-screen';
//import { StatusBar, StyleSheet, useColorScheme, View } from 'react-native';
// import {
//   SafeAreaProvider,
//   useSafeAreaInsets,
// } from 'react-native-safe-area-context';
import React, { ReactElement, useEffect, useState, useRef, useLayoutEffect } from "react";
import {  CommonActions, NavigationContainer, useNavigationContainerRef, useFocusEffect } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import BootSplash from "react-native-bootsplash";
import { Image, AppState, Dimensions, useWindowDimensions, NativeModules, NativeEventEmitter, DeviceEventEmitter,
  PixelRatio, View, Animated, useAnimatedValue, Pressable, StatusBar, BackHandler, EmitterSubscription } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import FastImage from '@d11/react-native-fast-image';
import AntDesign from 'react-native-vector-icons/AntDesign';
import Entypo from 'react-native-vector-icons/Entypo';
import FontAwesome5 from 'react-native-vector-icons/FontAwesome5';
import Ionicons from 'react-native-vector-icons/Ionicons';
import MaterialCommunityIcons from 'react-native-vector-icons/MaterialCommunityIcons';
import MaterialIcons from 'react-native-vector-icons/MaterialIcons';
import SimpleLineIcons from 'react-native-vector-icons/SimpleLineIcons';
//import { StackAnimationTypes, enableScreens } from "react-native-screens";
//import { SafeAreaProvider, SafeAreaView } from 'react-native-safe-area-context';
import { dimI, navigationI } from './src/interfaces/interfaces';
//import { addListener, startListener, stopListener } from './layoutListener';
import Home from './src/components/Home/Home';
import About from './src/components/About/About';
import KnowMore from './src/components/KnowMore/KnowMore';

const Stack = createNativeStackNavigator();

type StackAnimationTypes = 'none' | 'slide_from_right'

const { MainActivity } = NativeModules;
const nativeEvent = new NativeEventEmitter(MainActivity);

//let stopListener = nativeEvent.addListener('LayoutInfo', (e) => {
let stopListener: EmitterSubscription | null = nativeEvent.addListener('LayoutInfo', (e) => {
  console.log("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX tallNav", e.tallNav)
  // setLayout(e)
  // tallNav.current = e.tallNav
  //console.log("UPDATEEEEEEEEEEEEEEEEEEEEEEEEEEEE", tallNav.current)
  //if (runOnceAvailable.current) runOnce()
}) 

//startListener()
//startListener()

//const NavigatorMapper = (animation: StackAnimationTypes, tallNav: boolean, screens: ReactElement[]) => {
const NavigatorMapper = (animation: StackAnimationTypes, screens: ReactElement[]) => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
        gestureEnabled: false,
        animation: animation,
        statusBarStyle: 'dark',
      }}
      //children={ screens.map((e: ReactElement) => e) }
      //children={{...screens}}
      children={screens}
    />
  )
}

const App = (): ReactElement => {

  StatusBar.setBackgroundColor('transparent')

  let tallNav = useRef<boolean>(false) // tallNavigationBar

  const [ layout, setLayout ] = useState({
    "window": {"width": 0, "height": 0},
    "hingeBounds": {"left": 0, "top": 0, "right": 0, "bottom": 0},
    "insets": {"left": 0, "top": 0, "right": 0, "bottom": 0},
    "maxVerticalInset": 0,
    "maxHorizontalInset": 0,
    "state": "portrait",
    "vmin": 0,
    "tallNav": "false" // tallNavigationBar
  });

  console.log("INSETS ", layout.insets)
  console.log("STATE ", layout.state)

  const navigationRef = useNavigationContainerRef();

  // useEffect(() => {
  //   console.log("navigationRef APP", navigationRef.getState())
  // }, [navigationRef])

  const [ animation, setAnimation ] = useState<StackAnimationTypes>('none'); // NO INITIAL SCREEN ANIMATION

  let allRoutes = [{ name: 'Home' }, { name: 'About' }, { name: 'KnowMore' }]

  let routes = [
    { index: 2, routes: allRoutes }, // KnowMore
    { index: 1, routes: allRoutes.slice(0, 2) }, // About
    { index: 0, routes: allRoutes.slice(0, 1) } // Home
  ]

  const input = useRef(""); // MAIN DISPLAY (CENTER)
  const secInput = useRef(""); // SECONDARY DISPLAY (UPPER)
  const [ _, update ] = useState({}); // DUMMY USESTATE FOR DISPLAY UPDATE

  // API: Home:      Overview:                        StatusBar:
  // 36   background active                           active
  // 34   background active                           active
  // 31   background active                           active
  // 30   background background                       active
  // 29   background background                       active
  // 28   background background                       active
  // 26   background background                       active
  // 23   active     background (1st) / active (next) active
  useEffect(() => {
    const blur = AppState.addEventListener('blur', () => { // ON APP BLUR
      console.log("APP COMP APP BLURRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR")
      saveData("savedInput", input.current.toString())
      saveData("savedSecInput", secInput.current.toString())
      saveData("savedDate", Date.now().toString())
      console.log("CURRENT VALUEEEEEEEEEEEEEEEEEEEEE", tallNav.current)
      saveData("savedTallNav", tallNav.current.toString())
      let array = navigationRef.getState().routes // INSIDE ANY COMPONENT: navigation.getState().routes
      saveData("savedRoute", array[array.length - 1].name) // SAVE LAST ROUTE ON APP BLUR
      updateShowModal(false)
      console.log("savedRoute", array[array.length - 1].name)
    })
    return () => blur.remove()
  }, []);

  // useEffect(() => {

  //   BackHandler.addEventListener('hardwareBackPress', () => {
  //     console.log("BACK HANDLER: ", )
  //     //return true;
  //     return false;
  //   });

  // }, [])

  const saveData = async (key: string, value: string) => {
    try { await AsyncStorage.setItem(key, value) }
    catch(e) { }
  };

  const readData = async (key: string) => {
    try { return await AsyncStorage.getItem(key) }
    catch(e) { }
  };

  FastImage.preload([{ uri: Image.resolveAssetSource(require('./src/images/profile.png')).uri }])

  const [ showModal, setShowModal ] = useState(false);
  const updateShowModal = (bool: boolean) => setShowModal(bool)

  const fadeAnim: Animated.Value = useAnimatedValue(0); // ORIGINAL
  const fadeIn = () => Animated.timing(fadeAnim, { toValue: 1, duration: 1000, useNativeDriver: true }).start();
  const fadeOut = () => Animated.timing(fadeAnim, { toValue: 0, duration: 1000, useNativeDriver: true }).start();

  const width = layout.window.width
  const height = layout.window.height
  const state = layout.state
  const ins = layout.insets
  const hingeBounds = layout.hingeBounds
  const maxVerticalInset = layout.maxVerticalInset
  const maxHorizontalInset = layout.maxHorizontalInset
  const vmin = layout.vmin

  const sharedProps = { width, height, state, ins, hingeBounds, maxVerticalInset, maxHorizontalInset, vmin, fadeAnim, fadeIn, fadeOut }

  const dynamicImport = (nav: navigationI, module: string) => {
    switch (module) {
      case "Home":
        //const Home = require('./src/components/Home/Home').default
        return (
          <Home
            {...nav} {...sharedProps} input={input} secInput={secInput}
            showModal={showModal} updateShowModal={updateShowModal}
            update={update}
          />
        )
      case "About":
        //const About = require('./src/components/About/About').default
        return (
          <About
            {...nav} {...sharedProps} showModal={showModal}
            updateShowModal={updateShowModal} twoScreens={false}
          />
        )
      case "KnowMore":
        //const KnowMore = require('./src/components/KnowMore/KnowMore').default
        return <KnowMore {...nav} {...sharedProps} />
    }
  }

  //const fadeAnim = useAnimatedValue(0); // ORIGINAL

  // const ModalForegroundScreen =
  //   <Animated.View
  //     style={[ s.ModalForegroundScreen, { /* backgroundColor: 'orange', */opacity: fadeAnim, pointerEvents: showModal ? 'auto' : 'none' } ]}
  //     children={
  //       <Pressable
  //         style={[ s.ModalForegroundScreenPressable, { /* backgroundColor: 'yellow', */ paddingTop: ins.top, paddingBottom: ins.bottom } ]}
  //         onPress={() => {console.log('CLICKED Home');updateShowModal(false)}}
  //       />
  //     }
  //   />

  let stackScreens: ReactElement[] = [ "Home", "About", "KnowMore" ].map((e: string) => {
    return (
      <Stack.Screen
        name={e}
        key={e}
        options={{ contentStyle: { backgroundColor: "rgb(255, 255, 255)" } }} // DEFAULT APP BACKGROUND COLOR
        children={(nav) => dynamicImport(nav, e)}
      />
    )
  })

  //let initialState = { index: 0, routes: [ { name: 'Home' } ] }; // SET NAVIGATOR INITIAL STATE TO AVOID "UNDEFINED" ON "APP BLUR SAVE LAST ROUTE" (WITHOUT NAVIGATE ANY SCREEN)
  //let initialState = { index: 2, routes: [{ name: 'Home' }, { name: 'About' }, { name: 'KnowMore' }] }; // SET NAVIGATOR INITIAL STATE TO AVOID "UNDEFINED" ON "APP BLUR SAVE LAST ROUTE" (WITHOUT NAVIGATE ANY SCREEN)
  //let initialState = { index: 2, routes: [{ name: 'Home' }, { name: 'About' }] }; // SET NAVIGATOR INITIAL STATE TO AVOID "UNDEFINED" ON "APP BLUR SAVE LAST ROUTE" (WITHOUT NAVIGATE ANY SCREEN)
  let initialState = {
    type: 'stack',
    key: 'stack-1',
    routeNames: ['Home', 'About', 'KnowMore'],
    routes: [{ name: 'Home' }],
    //routes: [{ name: 'Home' }, { name: 'About' }, { name: 'KnowMore' }],
    index: 1,
    stale: false,
  };

  const runOnceAvailable = useRef(true)

  const runOnce = async () => {
    console.log("EXEC RUN ONCE")
    const resInput = await readData("savedInput") // RESPONSE INPUT
    const resSecInput = await readData("savedSecInput") // RESPONSE INPUT
    const resDate = await readData("savedDate") // RESPONSE DATE
    const resTallNav = await readData("savedTallNav") // RESPONSE HEIGHT
    const resRoute = await readData("savedRoute") // RESPONSE ROUTE

    typeof resInput === "string" && (input.current = resInput)
    typeof resSecInput === "string" && (secInput.current = resSecInput)

    console.log("RESTORED ROUTE: ", resRoute)

    try {
      await Promise.all([
        AntDesign.loadFont(),
        Entypo.loadFont(),
        FontAwesome5.getStyledIconSet('brand').loadFont(),
        FontAwesome5.getStyledIconSet('light').loadFont(),
        FontAwesome5.getStyledIconSet('regular').loadFont(),
        FontAwesome5.getStyledIconSet('solid').loadFont(),
        Ionicons.loadFont(),
        MaterialCommunityIcons.loadFont(),
        MaterialIcons.loadFont(),
        SimpleLineIcons.loadFont(),
      ])
    } catch (error) { console.log("VV FONT LOAD ERROR", error) }

    async function navigationBarToGestureOrViceVersa() {
      // if (typeof resDate === "string" && typeof resTallNav === "string" && typeof resRoute === "string") {
      //   if (Date.now() - parseInt(resDate) < 60000 && resTallNav !== tallNav.current.toString()) {
      //     resRoute === "KnowMore" ? navigationRef.dispatch(CommonActions.reset(routes[0])) :
      //     resRoute === "About" ? navigationRef.dispatch(CommonActions.reset(routes[1])) :
      //     navigationRef.dispatch(CommonActions.reset(routes[2]))
      //   } // else "WINDOWS HAS NOT CHANGED."
      // }
    }
    navigationBarToGestureOrViceVersa()
    .then(() => {
      setTimeout(() => { // ONLY FIRST TIME & WHEN DEVICE WINDOW DIMENSIONS CHANGE
        setAnimation('slide_from_right') // SLIDE SCREEN ANIMATION
        //setAnimation('none') // SLIDE SCREEN ANIMATION
        BootSplash.hide()
        console.log("runOnceAvailable.current", runOnceAvailable.current)
        runOnceAvailable.current = false
      }, 200) // AVOID ICON BLINKING
    })
  }

  useEffect(() => {
    console.log("EXEC USE EFFECT")
    // let inner = (e: any) => {
    //   console.log("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX tallNav", e.tallNav)
    //   setLayout(e)
    //   tallNav.current = e.tallNav
    //   //console.log("UPDATEEEEEEEEEEEEEEEEEEEEEEEEEEEE", tallNav.current)
    //   if (runOnceAvailable.current) runOnce()
    // }
    // //runOnce()
    // addListener(inner)

    //return () => stopListener.remove();


    // let stopListener = nativeEvent.addListener('LayoutInfo', (e) => {
    //   console.log("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX tallNav", e.tallNav)
    //   setLayout(e)
    //   tallNav.current = e.tallNav
    //   //console.log("UPDATEEEEEEEEEEEEEEEEEEEEEEEEEEEE", tallNav.current)
    //   if (runOnceAvailable.current) runOnce()
    // }) 

  // let stopListener = nativeEvent.addListener('LayoutInfo', (e) => {
  //   console.log("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX tallNav", e.tallNav)
  //   // setLayout(e)
  //   // tallNav.current = e.tallNav
  //   //console.log("UPDATEEEEEEEEEEEEEEEEEEEEEEEEEEEE", tallNav.current)
  //   //if (runOnceAvailable.current) runOnce()
  // }) 
    if (!stopListener) {
            // If it hasn't, create it and store the subscription object.
            // This ensures the listener is created early (like your original global setup)
            // but only *once* during the application's lifespan until explicitly removed.
            stopListener = nativeEvent.addListener('LayoutInfo', (e) => {
              console.log("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX tallNav", e.tallNav)
              // setLayout(e)
              // tallNav.current = e.tallNav
              //console.log("UPDATEEEEEEEEEEEEEEEEEEEEEEEEEEEE", tallNav.current)
              //if (runOnceAvailable.current) runOnce()
            })
        }

    //return () => stopListener.remove();
    return () => {
      if (stopListener) {
        stopListener.remove()
        stopListener = null
      }
    }

  }, []);

  return (
    <NavigationContainer
      ref={navigationRef}
      initialState={initialState}
      children={ NavigatorMapper(animation, stackScreens) }
    />
  );
}

export default App;